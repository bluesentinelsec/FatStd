// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/michaellong/projects/FatStd/pkg/fatstd_go/string_exports.go:1:1
package main

/*
#include <stdint.h>
*/
import _ "unsafe"

import (
	"unsafe"

	"github.com/bluesentinelsec/FatStd/pkg/fatstrings"
)

var fatstdHandles = newHandleRegistry()

func fatstdStringNewFromGoString(value string) uintptr {
	return fatstdHandles.register(fatstrings.NewUTF8(value))
}

func fatstdStringFromHandle(handle uintptr) *fatstrings.String {
	if handle == 0 {
		panic("fatstdStringFromHandle: handle is 0")
	}
	value, ok := fatstdHandles.get(handle)
	if !ok {
		panic("fatstdStringFromHandle: invalid handle")
	}
	s, ok := value.(*fatstrings.String)
	if !ok {
		panic("fatstdStringFromHandle: handle is not a fat string")
	}
	return s
}

//export fatstd_go_string_new_utf8_cstr
func fatstd_go_string_new_utf8_cstr(cstr * /*line :36:43*/_Ctype_char /*line :36:49*/)  /*line :36:51*/_Ctype_uintptr_t /*line :36:62*/ {
	if cstr == nil {
		panic("fatstd_go_string_new_utf8_cstr: cstr is NULL")
	}
	handle := fatstdStringNewFromGoString(( /*line :40:40*/_Cfunc_GoString /*line :40:49*/)(cstr))
	return  /*line :41:9*/_Ctype_uintptr_t /*line :41:20*/(handle)
}

//export fatstd_go_string_new_utf8_n
func fatstd_go_string_new_utf8_n(bytes * /*line :45:41*/_Ctype_char /*line :45:47*/, len  /*line :45:53*/_Ctype_size_t /*line :45:61*/)  /*line :45:63*/_Ctype_uintptr_t /*line :45:74*/ {
	if bytes == nil {
		if len == 0 {
			return  /*line :48:11*/_Ctype_uintptr_t /*line :48:22*/(fatstdStringNewFromGoString(""))
		}
		panic("fatstd_go_string_new_utf8_n: bytes is NULL but len > 0")
	}
	if len >  /*line :52:11*/_Ctype_size_t /*line :52:19*/(2147483647) {
		panic("fatstd_go_string_new_utf8_n: len too large")
	}

	buf := func() []byte{ _cgo0 := /*line :56:19*/unsafe.Pointer(bytes); var _cgo1 _Ctype_int = _Ctype_int /*line :56:47*/(len); _cgoCheckPointer(_cgo0, nil); return /*line :56:53*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	handle := fatstdStringNewFromGoString(string(buf))
	return  /*line :58:9*/_Ctype_uintptr_t /*line :58:20*/(handle)
}

//export fatstd_go_string_clone
func fatstd_go_string_clone(handle  /*line :62:36*/_Ctype_uintptr_t /*line :62:47*/)  /*line :62:49*/_Ctype_uintptr_t /*line :62:60*/ {
	s := fatstdStringFromHandle(uintptr(handle))
	cloned := fatstrings.Clone(s.Value())
	return  /*line :65:9*/_Ctype_uintptr_t /*line :65:20*/(fatstdStringNewFromGoString(cloned))
}

//export fatstd_go_string_contains
func fatstd_go_string_contains(aHandle  /*line :69:40*/_Ctype_uintptr_t /*line :69:51*/, bHandle  /*line :69:61*/_Ctype_uintptr_t /*line :69:72*/)  /*line :69:74*/_Ctype_int /*line :69:79*/ {
	a := fatstdStringFromHandle(uintptr(aHandle))
	b := fatstdStringFromHandle(uintptr(bHandle))
	if fatstrings.Contains(a.Value(), b.Value()) {
		return 1
	}
	return 0
}

//export fatstd_go_string_free
func fatstd_go_string_free(handle  /*line :79:35*/_Ctype_uintptr_t /*line :79:46*/) {
	if handle == 0 {
		panic("fatstd_go_string_free: handle is 0")
	}

	value, ok := fatstdHandles.take(uintptr(handle))
	if !ok {
		panic("fatstd_go_string_free: invalid handle")
	}
	if _, ok := value.(*fatstrings.String); !ok {
		panic("fatstd_go_string_free: handle is not a fat string")
	}
}
